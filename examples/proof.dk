(; Data type of booleans. ;)

B : Type.

true : B.
false : B.

(; Data type of natural numbers. ;)

N : Type.

0 : N.
s : N -> N.

def 1 := s 0.

(; Addition on natural numbers. ;)

def add : N -> N -> N.

add 0 ?x --> ?x.
add (s ?x) ?y --> s (add ?x ?y).

#EVAL (add (s 1) (s 1)).

(; Type of data type codes and their interpretation as types. ;)

U : Type.

def T : U -> Type.

bool : U.

T bool --> B.

nat : U.

T nat --> N.

pi : !a : U, (T a -> U) -> U.

T (pi ?a ?f) --> !x:T ?a, T (?f x).

(; Type of propositions and their interpretation as types. ;)

Prop : Type.

def P : Prop -> Type.

all : !a:U, (T a -> Prop) -> Prop.

P (all ?a ?f) --> !x:T ?a, P (?f x).

(; Induction principle on N. ;)

def nat_ind : !p:N -> Prop, P (p 0) -> (!n, P (p n) -> P (p (s n))) -> !n, P (p n).

nat_ind _  ?u _  0      --> ?u.
nat_ind ?p ?u ?v (s ?n) --> ?v ?n (nat_ind ?p ?u ?v ?n).

(; Boolean equality on N. ;)

def beq : N->N->B.

beq 0 0 --> true.
beq (s ?x) (s ?y) --> beq ?x ?y.
beq 0 (s _) --> false.
beq (s _) 0 --> false.

(; Leibniz equality. ;)

eq : !a:U, T a -> T a -> Prop.

refl : !a, !x, P (eq a x x).

(; 0 is right neutral for add. ;)

#PROOF add0r : !n, P (eq nat (add n 0) n).
  (; FIXME: try to infer nat. ;)
#PRINT.
(;#REFINE n => _.;)
#INFER nat_ind.
#REFINE (nat_ind (n => eq nat (add n 0) n) ?case0 ?caseS).
  (; FIXME: try to infer predicate. ;)
#PRINT.
