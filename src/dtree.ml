open Terms
open Extra

(** Type of the leaves of the tree.  See {!file:terms.ml}, {!recfield:rhs}. *)
type action = (term_env, term) Bindlib.mbinder

(** Tree type.  {!const:Leaf}[(t, a)] are the leaves of the tree holding the
    targets of the rewriting as an {!type:action}; for [t], see
    {!recfield:switch} of {!type:node_data}.  The term option evinces--if the
    leaf has been obtained by a switch--the term that has been matched before
    reaching the leaf.  The {!const:Node}[n] constructor allows primarily to
    perform a switch among subtrees recorded in {!recfield:children} of [n].
    {!const:Fail} is a matching failure. *)
type t = Leaf of term option * action
       | Node of node_data
       | Fail

(** Data contained in a node of the tree.  {!recfield:switch} contains the
    term on which the switch that gave birth to this node has been performed
    (or none if the node has been obtained by a default matrix);
    {!recfield:swap} indicates whether the columns of the matrix have been
    swapped before the switch, with an int indicating the column which has
    been swapped with the first one (or None if no swap is performed) and
    {!recfield:children} contains the subtrees. *)
and node_data = { switch : term option
                ; swap : int option
                ; children : t list}

(** [iter l n f t] is a generic iterator on trees; with function [l] performed
    on leaves, function [n] performed on nodes, [f] returned in case of
    {!const:Fail} on tree [t]. *)
let iter : (term option -> action -> 'a) ->
  (term option -> int option -> t list -> 'a) ->
  'a -> t -> 'a = fun do_leaf do_node fail t ->
  let rec loop = function
    | Leaf(teo, a)                                   -> do_leaf teo a
    | Fail                                           -> fail
    | Node({ switch = s ; swap = p ; children = c }) ->
      do_node s p (List.map loop c) in
  loop t

(** [to_dot f t] creates a dot graphviz file [f].gv for tree [t]. *)
let to_dot : string -> t -> unit = fun fname tree ->
  let module F = Format in
  let ochan = open_out (fname ^ ".gv") in
  let ppf = F.formatter_of_out_channel ochan in
  let nodecount = ref 0 in
  F.fprintf ppf "graph {@[<v>" ;
  let pp_opterm : term option pp = fun oc teo -> match teo with
    | Some(t) -> Print.pp oc t
    | None    -> F.fprintf oc "d" in
  let rec write_tree : int -> t -> unit = fun father_l tree ->
  (* We cannot use iter since we need the father to be passed. *)
    match tree with
    | Leaf(t, _)  ->
      incr nodecount ;
      F.fprintf ppf "@ %d -- %d [label=\"" father_l !nodecount ;
      pp_opterm ppf t ; F.fprintf ppf "\"];"
    | Node(ndata) ->
      let { switch = t ; swap = _ ; children = c } = ndata in
      incr nodecount ;
      let tag = !nodecount in
      F.fprintf ppf "@ %d -- %d [label=\"" father_l tag ;
      pp_opterm ppf t ; F.fprintf ppf "\"];" ;
      List.iter (fun e -> write_tree tag e) c ;
    | Fail        ->
      incr nodecount ;
      F.fprintf ppf "@ %d -- %d [label=\"%s\"];" father_l !nodecount "f"
  in
  write_tree 0 tree ;
  F.fprintf ppf "@.}@\n@?" ;
  close_out ochan

module Pattmat =
struct
  (** Type used to describe a line of a matrix (either a column or a row). *)
  type line = term list

  (** Mainly for debugging purposes, shows where the matrix comes from,
      i.e. generated by a specialization, a default case or the initial
      matrix *)
  type operation = Init
                 | Default
                 | Specialized of term

  (** Contains the rewrite rules. *)
  type matrix = (line * action) list

  (** Type of a matrix of patterns.  Each line is a row having an attached
      action. *)
  type t = { origin : operation
           ; values : matrix }

  (** [pp_line o l] prints line [l] to out channel [o]. *)
  let pp_line : line pp = List.pp Print.pp ";"

  (** [pp o m] prints matrix [m] to out channel [o]. *)
  let pp : t pp = fun oc { values = va ; _ } ->
    let module F = Format in
    F.fprintf oc "[|@[<v>@," ;
    List.pp pp_line "\n  " oc (List.map (fun (l, _) -> l) va) ;
    (* List.pp does not process Format "@" directives when in sep *)
    F.fprintf oc "@.|]@,@?"

  (** [of_rules r] creates the initial pattern matrix from a list of rewriting
      rules. *)
  let of_rules : rule list -> t = fun rs ->
    { values = List.map (fun r -> r.lhs, r.rhs) rs
    ; origin = Init }

  (** [is_empty m] returns whether matrix [m] is empty. *)
  let is_empty : t -> bool = fun m -> List.length m.values = 0

  (** [get_col n m] retrieves column [n] of matrix [m].  There is some
      processing because all rows do not have the same length. *)
  let get_col : int -> t -> line = fun ind { values = valu ; _ } ->
    let rec nth : 'a list -> int -> 'a option = fun l i ->
      match l with
      | []                 -> None
      | x :: _  when i = 0 -> Some(x)
      | _ :: xs when i > 0 -> nth xs (i - 1)
      | _ (* For linter *) -> assert false in
    let opcol = List.fold_left (fun acc (li, _) -> nth li ind :: acc) []
        valu in
    let rem = List.filter (function None -> false | Some(_) -> true) opcol in
    List.map (function Some(e) -> e | None -> assert false) rem

  (** [select m i] keeps the columns of [m] whose index are in [i]. *)
  let select : t -> int array -> t = fun m indexes ->
    { values = List.map (fun (l, a) ->
          (Array.fold_left (fun acc i -> List.nth l i :: acc) [] indexes),
          a) m.values
    ; origin = m.origin }

  (** [cmp c d] compares columns [c] and [d] returning:  +1 if c > d, 0 if c =
      d or -1 if c < d; where <, = and > are defined according to a heuristic.
  *)
  let cmp : line -> line -> int = fun _ _ -> 0

  (** [pick_best m] returns the index of the best column of matrix [m]
      according to a heuristic. *)
  let pick_best : t -> int = fun _ -> 0

  (** [is_pattern_free l] returns whether a line contains patterns or not.
      Typically, a line full of wildcards is pattern free. *)
  let rec is_pattern_free : line -> bool = function
    | []      -> true
    | x :: xs ->
      begin
        match x with
        (* Wildcards as Patt(None, _, _). *)
        | Patt(None, _, [| |]) -> is_pattern_free xs
        (* The condition might be too restrictive. *)
        | _                   -> false
      end

  (** [discard_patt_free m] returns the list of indexes of columns containing
      terms that can be matched against (discard pattern-free columns). *)
  let discard_patt_free : t -> int array = fun m ->
    let ncols = List.fold_left (fun acc (l, _) ->
        let le = List.length l in
      if le > acc then le else acc) 0 m.values in
    let pattfree = List.init ncols (fun k ->
        let col = get_col k m in
        is_pattern_free col) in
    let indexes = List.mapi (fun k pf ->
        if pf then None else Some k) pattfree in
    let remaining = List.filter (function
        | None    -> false
        | Some(_) -> true) indexes in
    let unpacked = List.map (function
        | Some(k) -> k
        | None    -> assert false) remaining in
    assert ((List.length unpacked) > 0) ;
    Array.of_list unpacked
end
