open Terms
open Extra

(** Type of the leaves of the tree.  See {!file:terms.ml}, {!recfield:rhs}. *)
type action = (term_env, term) Bindlib.mbinder

(** Tree type.  Leaves are the targets of the rewriting, i.e. when a leaf is
    reached, the matched pattern is rewrote to the the leaf.  The
    {!const:Node}[(i, t)] constructor allows to perform a switch among the
    subtrees in [t] while the [i] option allows to choose on which term of the
    stack the matching is to be done.  {!const:Fail} is a matching failure. *)
type t = Leaf of action
       | Node of node_data
       | Fail

(** Data contained in a node of the tree.  {!recfield:switch} contains the
    term on which the switch that gave birth to this node has been performed
    (or none if the node has been obtained by a default matrix);
    {!recfield:swap} indicates whether the columns of the matrix have been
    swapped before the switch, with an int indicating the column which has
    been swapped with the first one (or None if no swap is performed) and
    {!recfield:children} contains the subtrees. *)
and node_data = { switch : term option
                ; swap : int option
                ; children : t list}

(** [iter l n f t] is a generic iterator on trees; with function [l] performed
    on leaves, function [n] performed on nodes, [f] returned in case of
    {!const:Fail} on tree [t]. *)
let iter : (action -> 'a) -> (term option -> int option -> t list -> 'a) ->
  'a -> t -> 'a = fun do_leaf do_node fail t ->
  let rec loop = function
    | Leaf(a)                                        -> do_leaf a
    | Fail                                           -> fail
    | Node({ switch = s ; swap = p ; children = c }) ->
      do_node s p (List.map loop c) in
  loop t

(** [to_dot f t] creates a dot graphviz file [f].gv for tree [t]. *)
let to_dot : string -> t -> unit = fun fname tree ->
  let module F = Format in
  let ochan = open_out (fname ^ ".gv") in
  let ppf = F.formatter_of_out_channel ochan in
  let nodecount = ref 0 in
  F.fprintf ppf "graph {@[<v>" ;
  (* We cannot use iter since we need the father to be passed. *)
  let rec write_tree : int -> t -> unit = fun father_l tree ->
    match tree with
    | Leaf(_)    ->
      begin
        incr nodecount ;
        F.fprintf ppf "@ %d -- %d [label=\"%s\"];" father_l
          !nodecount "l";
      end
    | Node(ndata) ->
      let { switch = t ; swap = _ ; children = c } = ndata in
      begin
        incr nodecount ;
        let tag = !nodecount in
        F.fprintf ppf "@ %d -- %d [label=\"" father_l tag ;
        begin
          match t with
          | Some t' -> Print.pp ppf t'
          | None    -> F.fprintf ppf "d"
        end ;
        F.fprintf ppf "\"];" ;
        List.iter (fun e -> write_tree tag e) c ;
      end
    | Fail        ->
      begin
        incr nodecount ;
        F.fprintf ppf "@ %d -- %d [label=\"%s\"];" father_l
          !nodecount "f";
        end
  in
  write_tree 0 tree ;
  F.fprintf ppf "@.}@\n@?" ;
  close_out ochan

module Pattmat =
struct
  (** Type used to describe a line of a matrix (either a column or a row). *)
  type line = term list

  (** Mainly for debugging purposes, shows where the matrix comes from,
      i.e. generated by a specialization, a default case or the initial
      matrix *)
  type operation = Init
                 | Default
                 | Specialized of term

  (** Contains the rewrite rules. *)
  type matrix = (line * action) list

  (** Type of a matrix of patterns.  Each line is a row having an attached
      action. *)
  type t = { origin : operation
           ; values : matrix }

  (** [pp_line l] prints line [l] to stdout. *)
  let pp_line : line -> unit = fun l ->
    let module F = Format in
    let rec loop : term list -> unit = function
      | []      -> ()
      | x :: xs ->
        begin
          F.print_space () ; F.print_string ";" ;
          Print.pp Format.std_formatter x ;
          loop xs
        end in
    F.open_box 0 ;
    F.print_string "[" ; loop l ; F.print_string  "]" ;
    F.close_box () ; F.print_newline ()

  (** [pp m] prints matrix [m] to stdout. *)
  let pp : t -> unit = fun m ->
    let module F = Format in
    let rec loop : matrix -> unit = function
      | []           -> ()
      | (l, _) :: xs ->
        begin
          F.print_tab () ; pp_line l ; loop xs
        end in
    F.open_box 0 ;
    F.print_string "[|" ; F.print_cut () ; loop m.values ; F.print_string "|]" ;
    F.close_box () ; F.print_newline ()

  (** [of_rules r] creates the initial pattern matrix from a list of rewriting
      rules. *)
  let of_rules : rule list -> t = fun rs ->
    { values = List.map (fun r -> r.lhs, r.rhs) rs
    ; origin = Init }

  (** [is_empty m] returns whether matrix [m] is empty. *)
  let is_empty : t -> bool = fun m -> List.length m.values = 0

  (** [get_col n m] retrieves column [n] of matrix [m].  There is some
      processing because all rows do not have the same length. *)
  let get_col : int -> t -> line = fun ind mat ->
    List.fold_left (fun acc (elt, _) ->
        if List.length elt > ind then List.nth elt ind :: acc else acc) []
      mat.values

  (** [select m i] keeps the columns of [m] whose index are in [i]. *)
  let select : t -> int array -> t = fun m indexes ->
    { values = List.map (fun (l, a) ->
          (Array.fold_left (fun acc i -> List.nth l i :: acc) [] indexes),
          a) m.values
    ; origin = m.origin }

  (** [cmp c d] compares columns [c] and [d] returning:  +1 if c > d, 0 if c =
      d or -1 if c < d; where <, = and > are defined according to a heuristic.
  *)
  let cmp : line -> line -> int = fun _ _ -> 0

  (** [pick_best m] returns the index of the best column of matrix [m]
      according to a heuristic. *)
  let pick_best : t -> int = fun _ -> 0

  (** [is_pattern_free l] returns whether a line contains patterns or not.
      Typically, a line full of wildcards is pattern free. *)
  let rec is_pattern_free : line -> bool = function
    | []      -> true
    | x :: xs ->
      begin
        match x with
        (* Wildcards as Patt(None, _, _). *)
        | Patt(None, _, [| |]) -> is_pattern_free xs
        (* The condition might be too restrictive. *)
        | _                   -> false
      end

  (** [discard_patt_free m] returns the list of indexes of columns containing
      terms that can be matched against (discard pattern-free columns). *)
  let discard_patt_free : t -> int array = fun m ->
    let ncols = List.fold_left (fun acc (l, _) ->
        let le = List.length l in
      if le > acc then le else acc) 0 m.values in
    let pattfree = List.init ncols (fun k ->
        let col = get_col k m in
        is_pattern_free col) in
    let indexes = List.mapi (fun k pf ->
        if pf then None else Some k) pattfree in
    let remaining = List.filter (function
        | None    -> false
        | Some(_) -> true) indexes in
    let unpacked = List.map (function
        | Some(k) -> k
        | None    -> assert false) remaining in
    assert ((List.length unpacked) > 0) ;
    Array.of_list unpacked
end
